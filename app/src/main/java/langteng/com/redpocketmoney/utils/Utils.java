package langteng.com.redpocketmoney.utils;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Environment;import android.util.Log;import junit.framework.Assert;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Utils {	private final static String VAL_TYPE_WIFI = "wifi";	private final static String VAL_TYPE_CTWAP = "ctwap";	private static long lastClickTime;	/**	 * 是否500毫秒内快速双击	 *	 * @return	 */	public static boolean isDoubleClick() {		long time = System.currentTimeMillis();		if (time - lastClickTime < 500) {			lastClickTime = 0;			return true;		}		lastClickTime = time;		return false;	}	/**	 * 手机是否装了sd卡	 * 	 * @return	 */	public static boolean isSdPresent() {		return Environment.getExternalStorageState().equals(				Environment.MEDIA_MOUNTED);	}	/**	 * 添加快捷方式	 *	 * @param context	 */	public static void addShortcut(Context context) {//		Intent shortcut = new Intent(//				"com.android.launcher.action.INSTALL_SHORTCUT");////		// 快捷方式的名称//		shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME,//				context.getString(R.string.app_name));//		shortcut.putExtra("duplicate", false); // 不允许重复创建////		shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, new Intent(context,//				ActivitySplash.class));////		// 快捷方式的图标//		Intent.ShortcutIconResource iconRes = Intent.ShortcutIconResource.fromContext(//				context, R.mipmap.ic_launcher);//		shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes);////		context.sendBroadcast(shortcut);	}	/**	 * 创建文件下载路径	 * 	 * @param dir	 * @return	 */	public static boolean mkdir(String dir) {		File file = new File(dir);		if (!file.exists()) {			return file.mkdirs();		}		return true;	}	/**	 * 创建文件	 * @return	 */	public static boolean createFile(String file_path) {		try {			String directory_path = file_path.substring(0,					file_path.lastIndexOf(File.separator));			/* 查找目录，如果不存在，就创建 */			if (mkdir(directory_path)) {				/* 查找文件，如果不存在，就创建 */				File file = new File(file_path);				if (!file.exists())					return file.createNewFile();			} else {				return false;			}		} catch (Exception e) {		}		return false;	}	/**	 * 获取存储空间路径	 * 	 * @param context	 * @return	 */	public static String getStoragePath(Context context) {		if (Utils.isSdPresent()) {			// 是否存在于SD卡中			return Environment.getExternalStorageDirectory() + File.separator;		} else {			return context.getFilesDir().getAbsolutePath() + File.separator;		}	}	private static final String TAG = "SDK_Sample.Util";	public static byte[] bmpToByteArray(final Bitmap bmp, final boolean needRecycle) {		ByteArrayOutputStream output = new ByteArrayOutputStream();		bmp.compress(Bitmap.CompressFormat.PNG, 100, output);		if (needRecycle) {			bmp.recycle();		}		byte[] result = output.toByteArray();		try {			output.close();		} catch (Exception e) {			e.printStackTrace();		}		return result;	}	public static byte[] getHtmlByteArray(final String url) {		URL htmlUrl = null;		InputStream inStream = null;		try {			htmlUrl = new URL(url);			URLConnection connection = htmlUrl.openConnection();			HttpURLConnection httpConnection = (HttpURLConnection)connection;			int responseCode = httpConnection.getResponseCode();			if(responseCode == HttpURLConnection.HTTP_OK){				inStream = httpConnection.getInputStream();			}		} catch (MalformedURLException e) {			e.printStackTrace();		} catch (IOException e) {			e.printStackTrace();		}		byte[] data = inputStreamToByte(inStream);		return data;	}	public static byte[] inputStreamToByte(InputStream is) {		try{			ByteArrayOutputStream bytestream = new ByteArrayOutputStream();			int ch;			while ((ch = is.read()) != -1) {				bytestream.write(ch);			}			byte imgdata[] = bytestream.toByteArray();			bytestream.close();			return imgdata;		}catch(Exception e){			e.printStackTrace();		}		return null;	}	public static byte[] readFromFile(String fileName, int offset, int len) {		if (fileName == null) {			return null;		}		File file = new File(fileName);		if (!file.exists()) {			Log.i(TAG, "readFromFile: file not found");			return null;		}		if (len == -1) {			len = (int) file.length();		}		Log.d(TAG, "readFromFile : offset = " + offset + " len = " + len + " offset + len = " + (offset + len));		if(offset <0){			Log.e(TAG, "readFromFile invalid offset:" + offset);			return null;		}		if(len <=0 ){			Log.e(TAG, "readFromFile invalid len:" + len);			return null;		}		if(offset + len > (int) file.length()){			Log.e(TAG, "readFromFile invalid file len:" + file.length());			return null;		}		byte[] b = null;		try {			RandomAccessFile in = new RandomAccessFile(fileName, "r");			b = new byte[len]; // 创建合适文件大小的数组			in.seek(offset);			in.readFully(b);			in.close();		} catch (Exception e) {			Log.e(TAG, "readFromFile : errMsg = " + e.getMessage());			e.printStackTrace();		}		return b;	}	private static final int MAX_DECODE_PICTURE_SIZE = 1920 * 1440;	public static Bitmap extractThumbNail(final String path, final int height, final int width, final boolean crop) {		Assert.assertTrue(path != null && !path.equals("") && height > 0 && width > 0);		BitmapFactory.Options options = new BitmapFactory.Options();		try {			options.inJustDecodeBounds = true;			Bitmap tmp = BitmapFactory.decodeFile(path, options);			if (tmp != null) {				tmp.recycle();				tmp = null;			}			Log.d(TAG, "extractThumbNail: round=" + width + "x" + height + ", crop=" + crop);			final double beY = options.outHeight * 1.0 / height;			final double beX = options.outWidth * 1.0 / width;			Log.d(TAG, "extractThumbNail: extract beX = " + beX + ", beY = " + beY);			options.inSampleSize = (int) (crop ? (beY > beX ? beX : beY) : (beY < beX ? beX : beY));			if (options.inSampleSize <= 1) {				options.inSampleSize = 1;			}			// NOTE: out of memory error			while (options.outHeight * options.outWidth / options.inSampleSize > MAX_DECODE_PICTURE_SIZE) {				options.inSampleSize++;			}			int newHeight = height;			int newWidth = width;			if (crop) {				if (beY > beX) {					newHeight = (int) (newWidth * 1.0 * options.outHeight / options.outWidth);				} else {					newWidth = (int) (newHeight * 1.0 * options.outWidth / options.outHeight);				}			} else {				if (beY < beX) {					newHeight = (int) (newWidth * 1.0 * options.outHeight / options.outWidth);				} else {					newWidth = (int) (newHeight * 1.0 * options.outWidth / options.outHeight);				}			}			options.inJustDecodeBounds = false;			Log.i(TAG, "bitmap required size=" + newWidth + "x" + newHeight + ", orig=" + options.outWidth + "x" + options.outHeight + ", sample=" + options.inSampleSize);			Bitmap bm = BitmapFactory.decodeFile(path, options);			if (bm == null) {				Log.e(TAG, "bitmap decode failed");				return null;			}			Log.i(TAG, "bitmap decoded size=" + bm.getWidth() + "x" + bm.getHeight());			final Bitmap scale = Bitmap.createScaledBitmap(bm, newWidth, newHeight, true);			if (scale != null) {				bm.recycle();				bm = scale;			}			if (crop) {				final Bitmap cropped = Bitmap.createBitmap(bm, (bm.getWidth() - width) >> 1, (bm.getHeight() - height) >> 1, width, height);				if (cropped == null) {					return bm;				}				bm.recycle();				bm = cropped;				Log.i(TAG, "bitmap croped size=" + bm.getWidth() + "x" + bm.getHeight());			}			return bm;		} catch (final OutOfMemoryError e) {			Log.e(TAG, "decode bitmap failed: " + e.getMessage());			options = null;		}		return null;	}}